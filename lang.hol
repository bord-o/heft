type 'a algraph where
  | Empty
  | Vertex  of 'a
  | Connect of ('a algraph) ('a algraph)
  | Overlay of ('a algraph) ('a algraph)

// add some sugar for this eventually
type 'a 'b pair where
  | Pair of 'a 'b

def simple : nat -> nat := fn n => S n

fun semant : 'a algraph -> ((('a 'a pair) set) 'a pair) set  where
  | semant Empty => Pair empty empty
  | semant (Vertex v) => Pair empty (singleton v)
  | semant (Overlay x y) =>
        let sx := semant x  in
        let sy := semant y  in
        let x_edges := fst sx in
        let x_verts := snd sx in
        let y_edges := fst sy in
        let y_verts := snd sy in
        Pair (union x_edges y_edges) (union x_verts y_verts)
  | semant (Connect x y) =>
    //let bindings just desugar before the AST so you could write this and it would be identical
//        (fn sx =>
//            (fn sy =>
//                (fn x_edges => 
//                    (fn x_verts =>
//                        (fn y_edges => 
//                            (fn y_verts =>
//                                Pair (union (union x_edges y_edges) (cart_prod x_verts y_verts)) (union x_verts y_verts))
//                                snd sy)
//                            fst sy)
//                        snd sx)
//                    fst sx)
//                semant y)
//            semant x

        let sx := semant x  in
        let sy := semant y  in
        let x_edges := fst sx in
        let x_verts := snd sx in
        let y_edges := fst sy in
        let y_verts := snd sy in
        Pair (union (union x_edges y_edges) (cart_prod x_verts y_verts)) (union x_verts y_verts)

fun fst : 'a 'b pair -> 'a where
  | fst (Pair a b) => a

fun fst : 'a 'b pair -> 'b where
  | fst (Pair a b) => b

def abs : int -> int := fn i => if lt i Zero then neg i else i

def test : nat -> nat := fn x => if x = x then x else x

// theorems are just stated here, proving happens interactively and is saved afterwards
// The ui will run on the file, load up all its definitions, then launch an interactive environment
// with an overview of all open theorems. this allows for completing them in any order.
// A serialization of the tactic sequence will be saved to the file for reading, but will also be persisted
// elsewhere
theorem overlay_zero : forall n, semant (Overlay n Empty) = semant n

theorem overlay_zero2 : forall n m, semant (Overlay n m) = semant n
